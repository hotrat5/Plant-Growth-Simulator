// This file was generated by SquareLine Studio
// SquareLine Studio version: SquareLine Studio 1.4.2
// LVGL version: 8.3.11
// Project name: SquareLine_Project

#include "ui.h"
#include <stdio.h>
#include <stdbool.h>
#include <string.h>
#include <stdlib.h>

static char expression[100] = {0};


static void append_to_expression(const char* value){
	strcat(expression, value);
}

static void textarea_display(const char* text){
	lv_textarea_add_text(ui_ioput, text);
}

void click7(lv_event_t * e)
{
	append_to_expression("7");// Your code here
	textarea_display("7");
	

}

void click8(lv_event_t * e)
{
	// Your code here
	append_to_expression("8");
	textarea_display("8");
	
}

void click9(lv_event_t * e)
{
	// Your code here
	append_to_expression("9");
	textarea_display("9");
}

void click4(lv_event_t * e)
{
	// Your code here
	append_to_expression("4");
	textarea_display("4");
}

void click5(lv_event_t * e)
{
	// Your code here
	append_to_expression("5");
	textarea_display("5");
}

void click6(lv_event_t * e)
{
	// Your code here
	append_to_expression("6");
	textarea_display("6");
}

void click1(lv_event_t * e)
{
	// Your code here
	append_to_expression("1");
	textarea_display("1");
}

void click2(lv_event_t * e)
{
	// Your code here
	append_to_expression("2");
	textarea_display("2");
}

void click3(lv_event_t * e)
{
	// Your code here
	append_to_expression("3");
	textarea_display("3");
}

void click0(lv_event_t * e)
{
	// Your code here
	append_to_expression("0");
	textarea_display("0");
}

void clickmul(lv_event_t * e)
{
	// Your code here
	append_to_expression("*");
	textarea_display("*");
}

void clickdiv(lv_event_t * e)
{
	// Your code here
	append_to_expression("/");
	textarea_display("/");
}


void clickadd(lv_event_t * e)
{
	// Your code here
	append_to_expression("+");
	textarea_display("+");
	
}

void clicksub(lv_event_t * e)
{
	// Your code here
	append_to_expression("-");
	textarea_display("-");
}


/*
static char* calculate_exp(const char* expression) {
	
    static char result[20] = {0}; 
    double value = 0;
    char* endptr;
    
    if (strlen(expression) == 0) {
        strcpy(result, "0");
        return result;
    }
    
    value = strtod(expression, &endptr);
    
    // 如果整个表达式是一个数字，直接返回
    if (*endptr == '\0') {
        sprintf(result, "%.2f", value);
        return result;
    }
    
    double num1, num2;
    char op;
    
    num1 = strtod(expression, &endptr);
    if (*endptr == '\0') {
        sprintf(result, "%.2f", num1);
        return result;
    }
    
    op = *endptr++;
    
    num2 = strtod(endptr, &endptr);
    
    switch(op) {
        case '+':
            value = num1 + num2;
            break;
        case '-':
            value = num1 - num2;
            break;
        case '*':
            value = num1 * num2;
            break;
        case '/':
            if (num2 != 0) {
                value = num1 / num2;
            } else {
                strcpy(result, "Error");
                return result;
            }
            break;
        default:
            strcpy(result, "Error");
            return result;
    }
    
    // 格式化结果
    sprintf(result, "%.2f", value);
	printf("%f\n", value);
    return result;
}
*/

// 递归下降表达式求值
static const char* p; // 指向当前解析位置
static double parse_number();
static double parse_factor();
static double parse_term();
static double parse_expr();

// 跳过空格
static void skip_spaces() {
    while (*p == ' ') p++;
}

// 解析数字（支持小数）
static double parse_number() {
    skip_spaces();
    double val = strtod(p, (char**)&p);
    skip_spaces();
    return val;
}

// 解析括号或数字
static double parse_factor() {
    skip_spaces();
    double val = 0;
    if (*p == '(') {
        p++; // 跳过 '('
        val = parse_expr();
        if (*p == ')') p++; // 跳过 ')'
    } else {
        val = parse_number();
    }
    skip_spaces();
    return val;
}

// 解析乘除
static double parse_term() {
    double val = parse_factor();
    while (1) {
        skip_spaces();
        if (*p == '*') {
            p++;
            val *= parse_factor();
        } else if (*p == '/') {
            p++;
            double divisor = parse_factor();
            if (divisor == 0) {
                // 除零错误
                return 1e308; // 特殊值，后面处理
            }
            val /= divisor;
        } else {
            break;
        }
    }
    return val;
}

// 解析加减
static double parse_expr() {
    double val = parse_term();
    while (1) {
        skip_spaces();
        if (*p == '+') {
            p++;
            val += parse_term();
        } else if (*p == '-') {
            p++;
            val -= parse_term();
        } else {
            break;
        }
    }
    return val;
}

// 计算表达式主函数
static char* calculate_exp(const char* expression) {
    static char result[32] = {0};
    p = expression;
    skip_spaces();
    if (*p == '\0') {
        strcpy(result, "0");
        return result;
    }
    double val = parse_expr();
    skip_spaces();
    if (*p != '\0') {
        strcpy(result, "Error");
        return result;
    }
    if (val == 1e308) {
        strcpy(result, "Error");
        return result;
    }
    sprintf(result, "%.2f", val);
    return result;
}




void clickdel(lv_event_t * e)
{
	// Your code here
	lv_textarea_set_text(ui_ioput, "");
	memset(expression, 0, sizeof(expression));
	
}

void clickequal(lv_event_t * e) {

	printf("equal:%s\n", expression);
    // 先计算结果	
    char* value = calculate_exp(expression);
    
    // 清空输入区域并显示结果
    lv_textarea_set_text(ui_ioput, "");
    lv_textarea_add_text(ui_ioput, value);
    
    // 重置表达式，准备下一次计算
    memset(expression, 0, sizeof(expression));
    strcpy(expression, "0");
    
}